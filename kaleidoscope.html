<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaleidoscope</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
    <style>
        /* Basic CSS to ensure canvas fills the screen and remove scrollbars */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #14141E; /* Match initial background for seamless look */
            font-family: 'Inter', sans-serif; /* Consistent font */
        }
        canvas {
            display: block; /* Removes default bottom margin */
        }
        /* Styling for on-screen instructions */
        #instructions {
            position: fixed;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%); /* Center the instructions */
            padding: 8px 15px;
            background-color: rgba(40, 40, 60, 0.8); /* Semi-transparent dark background */
            color: #e0e0e0; /* Light text color */
            font-size: 13px;
            border-radius: 8px; /* Rounded corners */
            box-shadow: 0 2px 5px rgba(0,0,0,0.2); /* Subtle shadow */
            z-index: 10; /* Ensure it's above the canvas */
            text-align: center;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="instructions">
        Mouse Down & Drag: Draw | 'C': Clear | '+': Increase Symmetry | '-': Decrease Symmetry
    </div>

    <script>
        let symmetry = 8; // Initial number of kaleidoscope segments (slices)
        let angleOffset;  // Angle for each segment
        let hu = 0;       // Hue value for color cycling (0-255)

        // Function to set up the canvas and initial parameters
        function setup() {
            createCanvas(windowWidth, windowHeight); // Create a canvas that fills the browser window
            angleMode(DEGREES);   // Use degrees for rotation
            colorMode(HSB, 255);  // Use HSB color model (Hue, Saturation, Brightness, Alpha all 0-255)
            
            updateSymmetry(); // Calculate initial angleOffset and set background
            strokeCap(ROUND);     // Make line endings round for a smoother look
        }

        // Function to handle window resize events
        function windowResized() {
            resizeCanvas(windowWidth, windowHeight); // Adjust canvas size
            background(20, 20, 30); // Clear and redraw background on resize
                                    // This ensures the drawing doesn't get distorted
        }

        // Function to update symmetry settings and clear canvas
        function updateSymmetry() {
            angleOffset = 360 / symmetry; // Calculate the angle for each symmetry segment
            background(20, 20, 30); // Clear the canvas with a dark bluish background
                                    // This is important when symmetry changes or canvas is cleared
        }

        // Main drawing loop, called repeatedly by p5.js
        function draw() {
            // Only draw if the mouse is pressed and has moved since the last frame
            if (mouseIsPressed && (mouseX !== pmouseX || mouseY !== pmouseY)) {
                let centerX = width / 2;  // X-coordinate of the canvas center
                let centerY = height / 2; // Y-coordinate of the canvas center

                // Calculate current and previous mouse positions relative to the center of the canvas
                // This is important because transformations (like rotate) happen around the origin (0,0)
                let mx = mouseX - centerX;
                let my = mouseY - centerY;
                let pmx = pmouseX - centerX;
                let pmy = pmouseY - centerY;

                // Calculate mouse speed to vary stroke weight
                let speed = dist(mouseX, mouseY, pmouseX, pmouseY);
                // Map speed to stroke weight: faster movement = thinner line, slower = thicker
                let sw = map(speed, 0, 40, 15, 2); // (value, inMin, inMax, outMin, outMax)
                sw = constrain(sw, 1, 20); // Keep stroke weight within reasonable bounds
                strokeWeight(sw);

                // Set stroke color: cycling hue, high saturation and brightness, slight transparency
                stroke(hu, 220, 255, 200); 

                // Save current drawing state (transformations, styles)
                push();
                translate(centerX, centerY); // Move the origin to the center of the canvas

                // Loop through each symmetry segment
                for (let i = 0; i < symmetry; i++) {
                    push(); // Save transformation state for this segment
                    rotate(i * angleOffset); // Rotate the coordinate system for the current segment

                    // Draw the primary line (direct mouse stroke)
                    line(mx, my, pmx, pmy);

                    // Create a reflection within the segment
                    push(); // Save state before scaling (reflection)
                    scale(1, -1); // Reflect across the (new) x-axis of the rotated segment
                                  // This flips the y-coordinates
                    line(mx, my, pmx, pmy); // Draw the reflected line
                    pop(); // Restore state before scaling

                    pop(); // Restore transformation state for the next segment
                }
                pop(); // Restore global drawing state (origin back to top-left)

                // Increment hue for color cycling
                hu = (hu + 0.8) % 256; // Increment and wrap around 0-255
            }
        }

        // Function called when a key is pressed
        function keyPressed() {
            if (key === 'c' || key === 'C') {
                updateSymmetry(); // Effectively clears by redrawing background
            } else if (key === '+' || key === '=') { // '=' is often next to '+'
                symmetry++;
                updateSymmetry();
            } else if (key === '-') {
                if (symmetry > 1) { // Ensure symmetry doesn't go below 1
                    symmetry--;
                    updateSymmetry();
                }
            }
        }

        // Optional: If you want to clear the canvas when the mouse is released
        // function mouseReleased() {
        //     background(20, 20, 30); 
        // }
    </script>
</body>
</html>
